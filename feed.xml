<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://hassamwazir.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://hassamwazir.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-08T10:18:51+00:00</updated><id>https://hassamwazir.github.io/feed.xml</id><title type="html">blank</title><subtitle>Ph.D. New York University </subtitle><entry><title type="html">Embodied agents using a Turtlebot3 - A toy example</title><link href="https://hassamwazir.github.io/blog/2024/robot-llm/" rel="alternate" type="text/html" title="Embodied agents using a Turtlebot3 - A toy example"/><published>2024-08-28T16:00:16+00:00</published><updated>2024-08-28T16:00:16+00:00</updated><id>https://hassamwazir.github.io/blog/2024/robot-llm</id><content type="html" xml:base="https://hassamwazir.github.io/blog/2024/robot-llm/"><![CDATA[<p>Work in progress.</p> ]]></content><author><name>Hassam Khan Wazir</name></author><category term="post"/><category term="llm"/><summary type="html"><![CDATA[Understanding embdied agents with a Turtlebot3 and ROS.]]></summary></entry><entry><title type="html">NYU HPC Setup</title><link href="https://hassamwazir.github.io/blog/2023/nyu-hpc-setup/" rel="alternate" type="text/html" title="NYU HPC Setup"/><published>2023-12-21T16:40:16+00:00</published><updated>2023-12-21T16:40:16+00:00</updated><id>https://hassamwazir.github.io/blog/2023/nyu-hpc-setup</id><content type="html" xml:base="https://hassamwazir.github.io/blog/2023/nyu-hpc-setup/"><![CDATA[<p>This is a guide for logging into the NYU HPC cluster and streamlining that process.</p> <ul> <li> <p>The usual way to access the NYU Greene HPC cluster is via SSH. This information is taken from the official <a href="https://sites.google.com/nyu.edu/nyu-hpc/hpc-systems/greene/getting-started?authuser=0#h.niitlb309yhv">NYU HPC website</a>.</p> <ul> <li> <p>Simply open a terminal (Linux, Mac) or the Command Prompt (Windows 10) and enter the commands:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh &lt;netid&gt;@greene.hpc.nyu.edu ## you can skip this step if you  are on the NYU Network or using the NYU VPN
ssh &lt;netid&gt;@greene.hpc.nyu.edu
</code></pre></div> </div> <p>where <code class="language-plaintext highlighter-rouge">&lt;netid&gt;</code> is your NYU NetID. You will be prompted for your NYU NetID password. Enter it and you will be logged into the login node.</p> </li> </ul> </li> <li> <p>SSH keys can be set up as follows so that you don’t have to enter your password every time:</p> </li> <li> <p>On your local machine, generate a public/private key pair by running the command <code class="language-plaintext highlighter-rouge">ssh-keygen -t rsa</code> in a terminal. You will be prompted for a location to save the key pair. The default location is <code class="language-plaintext highlighter-rouge">~/.ssh/id_rsa</code> and <code class="language-plaintext highlighter-rouge">~/.ssh/id_rsa.pub</code> for the private and public keys, respectively. You can just press enter to accept the default location.</p> </li> <li> <p>Copy the public key to the login node by running the command <code class="language-plaintext highlighter-rouge">ssh-copy-id &lt;netid&gt;@login.greene.hpc.nyu.edu</code>. You will be prompted for your password. Enter it and the public key will be copied to the login node.</p> </li> <li> <p>Now you can log into the login node without entering your password by running the command <code class="language-plaintext highlighter-rouge">ssh &lt;netid&gt;@login.greene.hpc.nyu.edu</code>.</p> </li> <li> <p>As a final step, you can add the following lines to your <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> file to make logging in easier:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Host for ssh'ing into the Greene cluster when on the NYU network
Host greene
  HostName greene.hpc.nyu.edu
  User &lt;netid&gt;

# Host for 'tunneling' into the hpc when logging in from outside of the NYU network (i.e. at home)
Host hpcgwtunnel
  HostName gw.hpc.nyu.edu
  ForwardX11 no
  LocalForward 8025 greene.hpc.nyu.edu:22
  User &lt;netid&gt;

# Host for sshing into the greene cluster when tunneled in from outside of the NYU network (i.e. at home)
Host greenetunnel
  HostName localhost
  Port 8025
  ForwardX11 yes
  User &lt;netid&gt;
</code></pre></div> </div> </li> </ul> <p><strong>Note:</strong> In Windows 10, the <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> file is located at <code class="language-plaintext highlighter-rouge">C:\Users\&lt;username&gt;\.ssh\config</code>.</p> <p>Now you can log into the login node by simply running the command <code class="language-plaintext highlighter-rouge">ssh greene</code>.</p>]]></content><author><name></name></author><category term="post"/><category term="tutorial"/><summary type="html"><![CDATA[A guide for logging into the NYU HPC cluster and streamlining that process.]]></summary></entry><entry><title type="html">The z-domain transfer function and the Bilinear transformation.</title><link href="https://hassamwazir.github.io/blog/2020/imr-zdomain/" rel="alternate" type="text/html" title="The z-domain transfer function and the Bilinear transformation."/><published>2020-02-23T18:40:16+00:00</published><updated>2020-02-23T18:40:16+00:00</updated><id>https://hassamwazir.github.io/blog/2020/imr-zdomain</id><content type="html" xml:base="https://hassamwazir.github.io/blog/2020/imr-zdomain/"><![CDATA[<h2 id="understanding-mapping">Understanding mapping</h2> <p>The concept of mapping is used to transform one domain into another. It can be thought of as a value living in one space being transformed into another space. For example, the mapping of a point in the Cartesian plane to a point in the polar plane is a transformation from one space to another. In the context of control systems, the mapping of a transfer function from the <code class="language-plaintext highlighter-rouge">s-domain</code> to the <code class="language-plaintext highlighter-rouge">z-domain</code> is a transformation from the continuous-time domain to the discrete-time domain.</p> <p>This warping of the space is non-linear and the Bilinear transformation is used to account for this non-linearity.</p> <hr/> <h2 id="bilinear-transformation-from-the-s-domain-to-the-z-domain">Bilinear transformation from the s-domain to the z-domain</h2> <p>Assume we have a first-order system with a transfer function of the form:</p> <p>\begin{equation} G(s) = \frac{1}{s + 1} \end{equation}</p> <p>The z-domain transfer function is obtained by replacing \(s\) with \(\left(\frac{z - 1}{T}\right)\), where \(T\) is the sampling time. Let’s asume that a sampling time of \(1\) KHz was and the cut-off frequency \(\omega_c\) of \(10\) Hz`.</p> <p>Then, the time period \(T\) is given by: \begin{equation} T = \frac{1}{f_s} = \frac{1}{1000} = 0.001 \end{equation}</p> <p>The transfer function is given as follows: \begin{equation} H(j\omega) = \frac{\omega_c}{s + \omega_c} \end{equation}</p> <p>The transformation from s-domain to the z-domain is non-linear. To account for this non-linearity, the cut-off frequency is pre-warped and the resulting frequency is denoted by \(\omega_p\).</p> <p>\begin{equation} \omega_p = \frac{2}{T} \tan\left(\frac{\omega_c T}{2}\right) \end{equation}</p> \[\omega_p = 62.853\, \text{rad/s}\] <p>Once the frequency has been pre-warped, the system can undergo Bilinear transformation using the relationship between \(s\) and \(z\).</p> \[H(z) = \frac{\omega_p}{s + \omega_p} \bigg|_{s = \frac{2}{T} \frac{z-1}{z+1}}\] <p>Here, we evaluate the transfer function at \(s = \frac{2}{T} \frac{z-1}{z+1}\). In other words, we replace \(s\) with \(\frac{2}{T} \frac{z-1}{z+1}\).</p> \[H(z) = \frac{\omega_p}{\frac{2}{T} \frac{z-1}{z+1} + \omega_p}\] \[H(z) = \frac{\omega_p (z + 1)}{2000(z - 1) + \omega_p (z + 1)}\] \[H(z) = \frac{62.853z + 62.853}{2000z - 2000 + 62.853z + 62.853}\] \[H(z) = \frac{62.853z + 62.853}{2062.853z - 1937.147}\] \[H(z) = \frac{0.031z + 0.031}{z - 0.939} = \frac{0.031z^{-1} + 0.031}{1 - 0.939z^{-1}}\] \[\frac{Y(z)}{U(z)} = \frac{0.031z^{-1} + 0.031}{1 - 0.939z^{-1}}\] \[Y(z)(1 - 0.939z^{-1}) = U(z)(0.031z^{-1} + 0.031)\] <p>Here, the \(z^{-1}\) operator is the delay operator. The equation can be rewritten as:</p> \[Y[n] - 0.939 Y[n - 1] = 0.031 (U[n] + U[n - 1])\] <p>where \(Y[n]\) is the output at time \(n\) and \(U[n]\) is the input at time \(n\). The equation can be rewritten as:</p> <p>\begin{equation} \label{eq:diff_eq} Y[n] = 0.939 Y[n - 1] + 0.031 (U[n] + U[n - 1]) \end{equation}</p> <p>Equation \eqref{eq:diff_eq} is called the difference equation. The difference equation is used to implement the system in a digital computer. now the system can be implemented on a digital device such as a microcontroller.</p> <p>Here is an example implementation in Python:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>    <span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Number of samples
</span>
    <span class="c1"># Initialize arrays for Y and U
</span>    <span class="n">Y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>  <span class="c1"># List to store Y values, initialized to 0
</span>    <span class="n">U</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>  <span class="c1"># Example input list U
</span>
    <span class="c1"># Calculate Y values based on the given equation
</span>    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">Y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.939</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.031</span> <span class="o">*</span> <span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">U</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Print the resulting Y values
</span>    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Y[</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">] = </span><span class="si">{</span><span class="n">Y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>]]></content><author><name></name></author><category term="post"/><category term="controls"/><summary type="html"><![CDATA[Understanding the z-domain transfer function and the bilinear transformation.]]></summary></entry><entry><title type="html">Classical Controllers (P, I, D)</title><link href="https://hassamwazir.github.io/blog/2020/controls-controllers/" rel="alternate" type="text/html" title="Classical Controllers (P, I, D)"/><published>2020-02-21T17:00:16+00:00</published><updated>2020-02-21T17:00:16+00:00</updated><id>https://hassamwazir.github.io/blog/2020/controls-controllers</id><content type="html" xml:base="https://hassamwazir.github.io/blog/2020/controls-controllers/"><![CDATA[<p><a href="/blog/2020/controls-system-config/">In the previous post</a>, we discussed the configuration of control systems. In this post, we will discuss the common types of controllers used in classical control systems.</p> <h2 id="controllers">Controllers</h2> <p>Every plant has certain characteristics and will behave a certain way when provided a unit step input. For example, the plant,</p> <p>\begin{equation} \frac{Y(s)}{R(s)} = \frac{0.5}{0.1s + 1} \label{eqn:example_eq} \end{equation}</p> <p>will have a steady state value of \(0.5\) (because \(K=0.5\)) for unit step input.</p> <p>If, instead, we want to have a steady state value of \(1\) for the same unit step input, we can’t always change the plant itself. Therefore, we use a controller instead to “control” the output of the system. The controller is placed in cascade (in series) with the plant as shown below.</p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/controller.png" alt="Controller and plant in open-loop configuration." width="600px"/> <br/> <em>Figure 1: Controller and plant in an open-loop configuration.</em> </p> <p>To change the system in Equation \ref{eqn:example_eq}, so that the output is \(1\) when input is a unit step function, we can multiply the plant with \(2\). The controller, therefore, is just a constant gain of value \(2\). This type of controller is called a “Proportional controller”, and is the simplest type of controller that can be used.</p> <h3 id="proportional-p-controller">Proportional \((P)\) controller</h3> <p>As mentioned before, \(P\) controller is the simplest type of controller that can be used. The output of a Proportional controller is proportional to the input of the controller. It is just a gain (can be positive or negative and can be a fraction) that is multiplied by the plant to modify its system response. A real-world example would be the use of an amplifier to amplify the sound from a speaker by a fixed amount. Figure 2 shows the output of the system in Equation \ref{eqn:example_eq} in open-loop configuration. The steady state value is \(0.5\) as expected.</p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/withoutController.PNG" alt="Unit step response of the system." width="400px"/> <br/> <em>Figure 2: Unit step response of the system.</em> </p> <p>However, when a Proportional controller with a gain of \(2\) is used, the steady state value changes to \(1\), as shown in Figure 3.</p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/withController.PNG" alt="Unit step response of the system with Proportional controller." width="400px"/> <br/> <em>Figure 3: Unit step response of the system with Proportional controller.</em> </p> <h3 id="integral-i-controller">Integral \((I)\) controller</h3> <p>The output of an Integral controller is proportional to the integral of the input to the controller. In terms of a closed-loop system, as shown in Figure 4, the output of the \(I\) controller is the integral of the error term. Integral controllers are useful because they cause the system to have zero steady state error. Integral controllers will also increase the type of a system i.e., a first-order system will become a second-order system, and a second-order system will become a third-order system, and so on.</p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/integralController.PNG" alt="Closed-loop system with a PI controller." width="400px"/> <br/> <em>Figure 4: Closed-loop system with a PI controller.</em> </p> <h3 id="derivative-d-controller">Derivative \((D)\) controller</h3> <p>The output of a Derivative controller is proportional to the derivative of the input to the controller. In terms of a closed-loop system, the output of the \(D\) controller is the derivative of the error term. Derivative controllers are never used on their own and are usually paired with a \(P\) controller to make a \(PD\) controller, or a \(PI\) controller to make a \(PID\) controller. Derivative controllers are useful because they act as a dampener on the control effort. If the system is oscillating a lot, then the introduction of a derivative controller can damp those oscillations.</p> <h2 id="example-of-a-pi-controller">Example of a PI controller</h2> <p>Let us suppose that the plant we need to control is a first-order system with the following transfer function,</p> \[\frac{Y(s)}{R(s)} = \frac{2}{4s + 2}\] <p>We can calculate \(K=1\) and \(\tau=2\) as follows:</p> \[\frac{Y(s)}{R(s)} = \frac{2}{4s + 2} = \frac{\frac{2}{2}}{\frac{4s}{2} + \frac{2}{2}} = \frac{1}{2s + 1}\] <p>The closed-loop unit step response is shown in Figure 5.</p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/exampleSystem.PNG" alt="The closed-loop unit step response of the system." width="400px"/> <br/> <em>Figure 5: The closed-loop unit step response of the system.</em> </p> <p>As you can see, the system reaches a steady state around \(6\)s. But what if you want the system to reach a steady state at or less than \(2\)s? And the maximum overshoot you can tolerate is \(5\%\)? These are called system requirements and are chosen by you, or are given to you by someone who wants you to design the controller. Let’s design a PI controller that will give us the desired performance.</p> <p>The system requirements are,</p> <ul> <li>Percentage Overshoot \((PO) \leq 5\%\)</li> <li>\(2\%\) Settling time \((t_s) \leq 3s\)</li> </ul> <p>First of all, we need to create a block diagram of the system. The block diagram for a PI controller is shown in Figure 6.</p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/PIsystem1.PNG" alt="The PI controller with the plant." width="400px"/> <br/> <em>Figure 6: The PI controller with the plant.</em> </p> <p>This block diagram can be reduced in the following steps to get the transfer function in terms of variables \(P\) and \(I\) which are the proportional and integral gains respectively.</p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/PIsystem2.PNG" alt="Step 1 of reducing the block diagram." width="400px"/> <br/> <em>Figure 7: Step 1 of reducing the block diagram.</em> </p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/PIsystem3.PNG" alt="Step 2 of reducing the block diagram." width="400px"/> <br/> <em>Figure 8: Step 2 of reducing the block diagram.</em> </p> <p>Using the closed-loop formula,</p> \[\frac{G}{1+GH}\] <p>where \(G = \frac{2(Ps+I)}{4s^2 + 2s}\), and \(H=1\), the transfer function is,</p> \[\frac{Y(s)}{R(s)} = \frac{2(Ps+I)}{4s^2 + 2s + 2(Ps+I)}\] \[\frac{Y(s)}{R(s)} = \frac{2(Ps+I)}{4s^2 + 2s (1 + P) + 2I}\] <p>Divide the numerator and the denominator by \(4\) to make the coefficient of the highest power of \(s\) in the denominator equal to \(1\) (This will come in handy later).</p> <p>\begin{equation} \frac{Y(s)}{R(s)} = \frac{0.5(Ps+I)}{s^2 + 0.5s (1 + P) + 0.5I} \label{eqn:calculatedTF} \end{equation}</p> <p>Now that we have the transfer function in terms of \(P\) and \(I\), we need to calculate the desired \(\zeta\) and \(\omega_n\) of the system. These can be computed based on the system requirements.</p> <h3 id="calculating-zeta">Calculating \(\zeta\)</h3> \[\zeta = \sqrt{ \frac{\ln^2{(\frac{PO}{100})}} {\pi^2 + \ln^2{(\frac{PO}{100})}} }\] <p>Since \(PO \leq 5\%\),</p> \[\zeta \geq \sqrt{ \frac{\ln^2{(\frac{5}{100})}} {\pi^2 + \ln^2{(\frac{5}{100})}} }\] \[\zeta \geq 0.6901\] <h3 id="calculating-omega_n">Calculating \(\omega_n\)</h3> \[t_s \geq \frac{-\ln{(0.02)}}{\omega_n \zeta}\] <p>Since \(2\% (t_s \leq 3s\), and the calculated \(\zeta \geq 0.6901\),</p> \[\omega_n \geq \frac{-\ln{(0.02)}}{t_s \zeta}\] \[\omega_n \geq \frac{-\ln{(0.02)}}{(3)(0.6901)}\] \[\omega_n \geq 1.89 \text{ rad/s}\] <h3 id="putting-all-the-pieces-together">Putting all the pieces together</h3> <p>The transfer function we calculated is for a second-order system. We <a href="/blog/2020/controls-system-config/">previously mentioned</a> that the transfer function for a second-order system is of the general form,</p> \[\frac{Y(s)}{R(s)} = \frac{{\omega_n}^2}{s^2 + 2 \omega_n \zeta s + {\omega_n}^2}\] <p>Take the denominator of the general form and populate it with the calculated \(\zeta\) and \(\omega_n\) values.</p> \[s^2 + 2(1.89)(0.6901) s + {(1.89)}^2\] <p>Now make this equal to the denominator of the transfer function you derived from the block diagram (Equation \ref{eqn:calculatedTF}).</p> \[s^2 + 2(1.89)(0.6901) s + {(1.89)}^2 = s^2 + 0.5s (1 + P) + 0.5I\] <p>Now match the \(s\) terms and solve for the unknowns</p> <p>Finding \(P\),</p> \[2(1.89)(0.6901) s = 0.5s (1 + P)\] \[5.217 = 1 + P\] \[P = 4.214\] <p>Finding \(I\),</p> \[1.89^2 = 0.5I\] \[I = 7.144\] <p>Putting these values of \(P\) and \(I\) in the transfer function, we get the following unit-step response,</p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/PIgainsWrong.PNG" alt="Incorrect result after using the calculated PI gains." width="600px"/> <br/> <em>Figure 9: Incorrect result after using the calculated PI gains.</em> </p> <p>The settling time is below \(3\)s which fulfills the \(2\%\) requirement, however, the percentage overshoot is more than \(5\%\). This is because the calculation only provides a close guess of the required PI gains. After performing the calculation, the gains need to be manually tuned to get the desired system response. Upon manually tuning the \(P\) gain to \(8\), we get the desired system response as shown in Figure 10. The \(I\) gain was not changed.</p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/PIgainsRight.PNG" alt="Correct result after tuning the PI gains." width="600px"/> <br/> <em>Figure 10: Correct result after tuning the PI gains.</em> </p> <p><strong>Note:</strong> The gains can also be manually tuned without performing the calculation. However, the time it takes to get the desired gains will vary. You might be able to find the gains very quickly, or it might take a very long time. Therefore, performing the calculations gives you a good starting guess and you can start tuning the gains from there.</p> <h2 id="pid-controllers-and-third-order-systems">PID controllers and third-order systems</h2> <p>The calculation of a third-order system follows in a similar way as a second-order system with a small difference. The block diagram of a plant with a PID controller is shown below.</p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/pid.PNG" alt="The PID controller with the plant." width="400px"/> <br/> <em>Figure 11: The PID controller with the plant.</em> </p> <h3 id="calculating-the-pid-gains">Calculating the PID gains</h3> <p>The block diagram shown in Figure 11 can be reduced similarly as shown for the PI controller but with three variables i.e., \(P\), \(I\), and \(D\) gains. If the plant is a second-order system (as shown in Figure 11), then the overall transfer function will result in a third-order system. Since we only know how to solve for a second-order system, we do a little trick. The transfer function of Figure 11 is shown below:</p> \[\frac{Y(s)}{R(s)} = \frac{\frac{Ds^2+Ps+I}{2}}{s^3 + s^2\frac{(1+D)}{2} + s\frac{P}{2} + \frac{I}{2}}\] <p>Since we know that a third-order system has 3 poles, we choose one of the poles and then calculate the rest of the two poles using the system requirements (Percentage overshoot and Settling time).</p> <h4 id="choosing-the-third-pole">Choosing the third pole</h4> <p>To explain the choice of a pole, let us take an example transfer function and see how its poles and zeros (the roots of the denominator and numerator, respectively) look like in the s-plane. In the figure below, the root locus for a third-order system with the following transfer function is shown:</p> \[\frac{Y(s)}{R(s)} = \frac{s+1}{s^3 + 57s^2 + 360s + 500}\] <p>The system has poles at \(-2\), \(-5\), and \(-50\) and a zero at \(-1\).</p> <p align="center"> <img src="/assets/img/posts/2020-02-21-controls-controllers/PIDrootLocus.PNG" alt="Root locus of a third-order system with poles at $$-2$$, $$-5$$, and $$-50$$ and a zero at $$-1$$." width="400px"/> <br/> <em>Figure 12: Root locus of a third-order system with poles at \(-2\), \(-5\), and \(-50\) and a zero at \(-1\).</em> </p> <p>Any third-order system behaves like a second-order system if one of the three poles of the system (the order of the system tells how many poles it has) is to the far left of the imaginary axis.</p> <p>In the example shown in Figure 12, the third pole at \(-50\) is very far to the left of the imaginary axis and therefore, has minimal effect on the system response. The nearer a pole is to the imaginary axis, the more impact it has on the system response.</p> <p>With this knowledge, and the knowledge that the characteristic equation of a second-order system is as follows,</p> \[s^2 + 2\omega_n \zeta s + {\omega_n}^2\] <p>we can write down the characteristic equation of the third-order system. We can imagine a third pole more than \(5\) times that of the other two poles and place it at the far left of the imaginary axis. The resulting equation is,</p> \[(s-\alpha)(s^2 + 2\omega_n \zeta s + {\omega_n}^2)\] <p>where \(\alpha\) is the pole that we choose. We can choose an arbitrarily large negative value such as \(-100\), or we can choose \(\alpha\) to be \(-\omega\zeta\). In either case, we have a third pole that will not affect the system response too much and will allow us to approximate the third-order system as a second-order system. After this step, the calculation is similar to that of a system with a PI controller.</p> <h3 id="system-requirements-and-calculating-the-pid-gains">System requirements and calculating the PID gains</h3> <p>The system requirements to design the PID controller for the system shown in Figure 15 are,</p> <ul> <li>Percentage Overshoot \((PO) \leq 5\%\)</li> <li>\(2\%\) Settling time \((t_s) \leq 3s\)</li> </ul> <p>Based on these system requirements, the calculations follow from the PI controller example in part 6.</p> <ul> <li>The resultant \(\zeta \geq 0.6901\)</li> <li>The resultant \(\omega_n \geq 1.89 \text{ rad/s}\)</li> </ul> <p>We can choose the third pole \(\alpha = -100\) and put the \(\zeta\) and \(\omega_n\) values calculated above, in the third-order characteristic equation below,</p> \[(s-\alpha)(s^2 + 2\omega_n \zeta s + {\omega_n}^2)\] \[(s+100)(s^2 + 2(1.89)(0.6901) s + {(1.89)}^2)\] \[(s+100)(s^2 + 2.609 s + 3.572)\] \[s^3 + 2.609 s^2 + 3.572s + 100s^2 + 260.9s + 357.2\] \[s^3 + 102.609 s^2 + 364.472s + 357.2\] <p>Once we have this equation, we can equate it to the denominator of the transfer function we found for the system in Figure 11.</p> \[s^3 + 102.609 s^2 + 364.472s + 357.2 = s^3 + s^2\frac{(1+D)}{2} + s\frac{P}{2} + \frac{I}{2}\] \[102.609s^2 = \frac{1+D}{2}s^2\] \[D = 204.218\] \[364.472s = \frac{P}{2}s\] \[P = 728.944\] \[357.2 = \frac{I}{2}\] \[I = 714.4\] <p>Since we are approximating a second-order system behavior from a third-order system, after calculating the PID gains, we might need to manually tune them to get the desired system response.</p>]]></content><author><name></name></author><category term="post"/><category term="controls"/><summary type="html"><![CDATA[In this post, we will discuss the common types of controllers used in classical control systems.]]></summary></entry><entry><title type="html">System Configuration, Transfer Function, Laplace Transform, and System Order.</title><link href="https://hassamwazir.github.io/blog/2020/controls-system-config/" rel="alternate" type="text/html" title="System Configuration, Transfer Function, Laplace Transform, and System Order."/><published>2020-02-20T16:00:16+00:00</published><updated>2020-02-20T16:00:16+00:00</updated><id>https://hassamwazir.github.io/blog/2020/controls-system-config</id><content type="html" xml:base="https://hassamwazir.github.io/blog/2020/controls-system-config/"><![CDATA[<h2 id="system-configuration">System configuration</h2> <p>A <strong>plant</strong> (also referred to as a <em>process</em>) in control theory is something that receives an input and after processing it, gives a specific output. A plant is usually denoted by \(G\). A system is composed of other smaller sub-systems such as plants and controllers etc. A system can have open-loop and closed-loop configurations.</p> <h3 id="open-loop-system">Open-loop system</h3> <p>The figure below shows a system in an open-loop configuration. An open-loop system receives an <strong>input</strong> and gives back an <strong>output</strong>. However, the output does not influence the input in any way.</p> <p align="center"> <img src="/assets/img/posts/2020-02-20-controls-system-config/openloop.png" alt="An open-loop system" width="600px"/> <br/> <em>Figure 1: An open-loop system</em> </p> <p>For example, a DC motor in an open-loop configuration takes <em>voltage</em> \((V)\) as an input and gives <em>angular velocity</em> \((\omega)\) as an output. You can change \(V\) to change \(\omega\) but the change in \(\omega\) does not influence \(V\). Figure 2 shows an example of a DC motor receiving an input and giving an output.</p> <p align="center"> <img src="/assets/img/posts/2020-02-20-controls-system-config/DCopenLoop.PNG" alt="DC motor in open loop configuration and the resulting output when a constant 1 V input is given" width="600px"/> <br/> <em>Figure 2: DC motor in open loop configuration and the resulting output when a constant 1 V input is given</em> </p> <h3 id="closed-loop-system">Closed-Loop System</h3> <p>In a closed-loop system, a fraction of the output is fed back to the input and either added to or subtracted from the input. If the output is added, we call this a <em>positive feedback</em> system. If the output is subtracted from the input, we call it a <em>negative feedback</em> system. For system robustness, we typically use a negative feedback control. The feedback gain is denoted by \(H\). If there is no \(H\) in the feedback loop, then the value of \(H\) is considered to be 1 and the entire output is fed back to the input (for the sake of clarity, \(G(s)\) and \(H(s)\) are shown as \(G\) and \(H\)).</p> <p align="center"> <img src="/assets/img/posts/2020-02-20-controls-system-config/closedLoop.png" alt="A closed-loop system with plant $$G(s)$$ and feedback $$H(s)$$." width="600px"/> <br/> <em>Figure 3: A closed-loop system with plant \(G(s)\) and feedback \(H(s)\).</em> </p> <p>Here, \(R\) is the input, \(Y\) is the output, \(E\) is the error (difference between input and the feedback value)</p> \[E(s) = R(s) - Y(s)H(s)\] <hr/> <h2 id="transfer-function">Transfer Function</h2> <p>A Transfer Function is the ratio of the output of a system to the input of a system in the Laplace domain, considering its initial conditions and equilibrium point to be zero.</p> <p>For the Block diagram in Figure 3, the transfer function is calculated as follows (for the sake of clarity, \((s)\) is omitted from the equations. All terms are in the Laplace domain):</p> \[Y = GE\] <p>Substituting \(E = R(s) - Y(s)H(s)\) in the equation above, we get,</p> \[Y = G\left(R - YH\right)\] \[Y = GR - GYH\] \[Y + GYH = GR\] \[Y(1 + GH) = GR\] \[Y = \frac{GR}{(1 + GH)}\] <p>Finally, the transfer function is:</p> \[\frac{\text{Output}}{\text{Input}} = \frac{Y(s)}{R(s)} = \frac{G}{1 + GH}\] <h3 id="laplace-transform">Laplace Transform</h3> <p>The transfer function of a given system can be computed by first deriving its differential equations. Then convert those time domain equations into the Laplace domain by applying the Laplace transform. The third step is to find the ratio of the output to the input and that is the transfer function of that particular system.</p> <p>For example, for a spring mass damper system with an input force \(f(t)\), mass \((m)\), damping coefficient \((d)\), and spring constant \((k)\), the differential equation is as follows:</p> \[m\ddot{x}(t) + d\dot{x}(t) + kx(t) = f(t)\] <p>To take the Laplace transform of a quantity that is a function of time \(t\) when the initial condition is 0, the following transformation can be used.</p> \[x(t) \text{ becomes } X(s)\] \[\dot{x}(t) \text{ becomes } sX(s)\] \[\ddot{x}(t) \text{ becomes } s^2X(s)\] <p>and so on.</p> <p>With this information, we can convert the equation above to the Laplace domain using the Laplace transform.</p> \[m\ddot{x}(t) + d\dot{x}(t) + kx(t) = f(t)\] <p>becomes</p> \[ms^2X(s) + dsX(s) + kX(s) = F(s)\] <p>Now for the last part, we can find the ratio of output \(X(s)\) to the input \(F(s)\).</p> \[X(s)(ms^2 + ds + k) = F(s)\] \[\frac{X(s)}{F(s)} = \frac{1}{ms^2 + ds + k}\] <p>Congratulations, now you know how to compute a transfer function!</p> <p><strong>Note:</strong> This is a simplification of the Laplace transform calculation and is ONLY valid if the initial conditions are considered to be 0. The good news is that is all we need for the course. The actual Laplace transform looks like this,</p> \[\mathcal{L}\{f\}(s) = \int_{0}^{\infty} f(t) e^{-st} dt\] <hr/> <h2 id="system-order">System Order</h2> <p>The order of a system depends on the highest order of the derivative in the differential equation of a system. For a system with a differential equation,</p> \[\ddot{x}(t) + a\dot{x}(t) = b\] <p>The highest order of derivative is 2 (you have a double derivative in the equation). Therefore, it is a \(2^{nd}\) order system.</p> <p>In the Laplace domain, the order of the system can be determined by looking at the highest power of the \(s\) term. In the following transfer function,</p> \[\frac{Y(s)}{R(s)} = \frac{s + 1}{s^3 + 2s^2 + 6s + 4}\] <p>the highest power of \(s\) is 3, therefore, it is a \(3^{rd}\) order system.</p> <hr/> <h2 id="system-response">System response</h2> <p>The system response refers to the system output when a known input is given to the system. Typically, a unit step function is used as an input and is shown below:</p> <p align="center"> <img src="/assets/img/posts/2020-02-20-controls-system-config/stepFunction.png" alt="The unit step function." width="300px"/> <br/> <em>Figure 4: The unit step function.</em> </p> <p>The unit step function has a value of 0 before time \(t = 0\), and a value of 1 onward. This is used as an input because it is the simplest input possible and is used as a standard to compare the outputs. Other inputs include an impulse function, ramp function, etc.</p> <h3 id="1st-order-systems">\(1^{st}\) order systems</h3> <p>A first-order system has a transfer function of the following form:</p> \[\frac{Y(s)}{R(s)} = \frac{K}{\tau s + 1}\] <p>where \(K\) is called the DC gain and \(\tau\) is the time constant of the system.</p> <p>Figure 5 shows the unit step response of a \(1^{st}\) order system, and can be explained by the following equation in the time domain,</p> \[y(t) = (y(0) - y_{\infty})e^{(- \frac{t}{\tau})} + y_{\infty}\] <p align="center"> <img src="/assets/img/posts/2020-02-20-controls-system-config/firstOrder.png" alt="First order system with K and tau calculation." width="600px"/> <br/> <em>Figure 5: First order system with \(K\) and \(\tau\) calculation.</em> </p> <h4 id="transient-and-steady-state">Transient and Steady state</h4> <p>The <strong>transient state</strong> of a step response is when the output changes at every time instant. The <strong>steady state</strong> of a system is when the output reaches a steady value and does not change at every time instant.</p> <p>In Figure 5, the transient state starts from time \(t = 0\) and ends at \(t = 6\). The steady state starts when the transient state ends and goes on until \(t = \infty\).</p> <p>In closed-loop systems, if the steady-state output is not the same as the input, then the difference between the input and the output is called <strong>steady state error</strong>.</p> <h4 id="k-and-tau-calculation">\(K\) and \(\tau\) calculation</h4> <p>The transfer function of a first-order system can be calculated from its step response graph. <strong>\(K\)</strong> is the DC gain of the system and is equal to the steady state value of the system. In Figure 5, the steady state value is 5, therefore \(K = 5\). To calculate \(\tau\), find the time at which the output reaches 63.2% of \(K\). Since \(K = 5\) in Figure 5, 63.2% of \(K\) is 3.16. The time at \(y = 3.16\) is 1s. Therefore, \(\tau = 1\)s. Using this information, we can find the transfer function of the system in Figure 5 to be,</p> \[\frac{Y(s)}{R(s)} = \frac{K}{\tau s + 1} = \frac{5}{s + 1}\] <h3 id="2nd-order-systems">\(2^{nd}\) order systems</h3> <p>A second order system has a transfer function of the following form:</p> \[\frac{Y(s)}{R(s)} = \frac{{\omega_n}^2}{s^2 + 2 \omega_n \zeta s + {\omega_n}^2}\] <p>where \(\omega_n\) is the natural frequency and \(\zeta\) is the damping ratio of the system.</p> <p>Figure 6 shows the unit step response of a \(2^{nd}\) order system and the effect of changing the damping ratio \((\zeta)\) on the system response.</p> <p align="center"> <img src="/assets/img/posts/2020-02-20-controls-system-config/secondOrder.png" alt="Effect of damping ratio zeta) on the unit step response of a second-order system." width="600px"/> <br/> <em>Figure 6: Effect of damping ratio \(\zeta\) on the unit step response of a second-order system.</em> </p> <p>For a stable system, \(\zeta\) can have four different states. These states are discussed below.</p> <h4 id="undamped-system-zeta--0">Undamped system \((\zeta = 0)\)</h4> <p>When a system is undamped, it oscillates for time \(t = \infty\) because there is no damping in the system. Therefore, the system is stable, i.e., the output never diverges (it is bounded), and it never reaches a steady state.</p> <h4 id="under-damped-system-zeta--1">Under-damped system \((\zeta &lt; 1)\)</h4> <p>When a system is under-damped, the output initially overshoots the input (desired) value and then after several oscillations, reaches a steady state. The oscillations are a result of the under-damping of the system and some oscillation in the system is usually acceptable. However, this also depends on the system in question. For some critical systems, we do not want any oscillations, for others, we do not care that much about minor oscillations.</p> <h4 id="critically-damped-system-zeta--1">Critically damped system \((\zeta = 1)\)</h4> <p>When a system is critically damped, the output reaches a steady state without any overshoot. However, any minor reduction in the damping ratio (0.999 for example) will cause an overshoot in the output.</p> <h4 id="over-damped-system-zeta--1">Over-damped system \((\zeta &gt; 1)\)</h4> <p>A system is over-damped when it reaches a steady state without any oscillations and a small decrease in the damping ratio doesn’t cause any overshoot/oscillations.</p> <h4 id="zeta-and-omega_n-calculation">\(\zeta\) and \(\omega_n\) calculation</h4> <p>To calculate \(\zeta\) and \(\omega_n\), we need to know the following two pieces of information:</p> <ul> <li>Percentage Overshoot \((PO)\) - The percentage by which the output overshot the input value</li> <li>Settling time \((t_s)\) - the time it took for the system to reach steady state</li> </ul> <p><strong>Note:</strong> Since the system oscillates for quite a while very close to the steady state, we take settling time as the time when the output is 2% of the steady state (when output is within the 2% range of the steady state. For example, if the steady state is 1, the settling time can be the time it takes for the output to reach 1.02 or 0.98 or any value in between, whichever comes first).</p> <p>As an example, we will consider a system with 5% overshoot \((PO)\) and a settling time \((t_s)\) of 3s.</p> <p>Damping ratio \((\zeta)\) can be calculated as follows:</p> \[\zeta = \sqrt{ \frac{\ln^2{(\frac{PO}{100})}} {\pi^2 + \ln^2{(\frac{PO}{100})}} }\] \[\zeta = \sqrt{ \frac{\ln^2{(\frac{5}{100})}} {\pi^2 + \ln^2{(\frac{5}{100})}} }\] \[\zeta = 0.6901\] <p>Natural frequency \((\omega_n)\) can be calculated as follows:</p> \[t_s = \frac{-\ln{(0.02)}}{\omega_n \zeta}\] \[\omega_n = \frac{-\ln{(0.02)}}{t_s \zeta}\] \[\omega_n = \frac{-\ln{(0.02)}}{(3)(0.6901)}\] \[\omega_n = 1.89 \text{ rad/s}\] <p><strong>Note:</strong> The 0.02 in -\(\ln{(0.02)}\) refers to the 2% settling time. If you want to consider a 1% settling time, just change the value to 0.01.</p> <p>In the <a href="/blog/2020/controls-controllers/">next post</a>, we will discuss the different types of controllers and their effects on the system response.</p>]]></content><author><name></name></author><category term="post"/><category term="controls"/><summary type="html"><![CDATA[Understanding what a system is, its configuration, transfer function, Laplace transform, and system order.]]></summary></entry></feed>